{"version":3,"sources":["webpack:///../stories/multi-graph-layout/multi-graph-layout.js","webpack:///../stories/multi-graph-layout/app.js","webpack:///./node_modules/core-js/modules/es6.math.hypot.js"],"names":["defaultOptions","alpha","nBodyStrength","nBodyDistanceMin","nBodyDistanceMax","ForceMultiGraphLayout","options","_this","_BaseLayout","call","this","_strength","d3Edge","isVirtual","edgeCount","sourceDegree","_graph","getDegree","id","targetDegree","Math","getNodePosition","node","d3Node","_nodeMap","x","y","getEdgePosition","edge","_edgeMap","type","EDGE_TYPE","LINE","sourcePosition","targetPosition","controlPoints","virtualEdge","virtualEdgeId","distance","index","symmetricShape","controlPoint","source","target","direction","offset","midPoint","dx","normal","length","normalized","computeControlPoint","SPLINE_CURVE","lockNodePosition","_callbacks","onLayoutChange","onLayoutDone","_name","_options","Object","assign","_d3Graph","nodes","edges","initializeGraph","updateGraph","graph","_generateSimulator","_simulator","on","_this$_options","g","d3","d3_force_src","n","strength","start","restart","resume","stop","_this2","newNodeMap","newD3Nodes","getNodes","map","oldD3Node","newD3Node","nodePairs","getEdges","reduce","res","pairId","getSourceNodeId","getTargetNodeId","toString","newD3Edges","newEdgeMap","betweenEdges","firstEdge","newD3Edge","getId","e","idx","BaseLayout","MultiGraphExample","render","react_default","a","createElement","src","JSONLoader","json","sampleGraph","layout","multi_graph_layout_ForceMultiGraphLayout","nodeStyle","props","showNodePlaceholder","NODE_TYPE","CIRCLE","radius","fill","showNodeCircle","nodeColor","showNodeLabel","LABEL","text","color","Color","array","fontSize","nodeLabelSize","edgeStyle","stroke","edgeColor","strokeWidth","edgeWidth","decorators","showEdgeLabel","EDGE_DECORATOR_TYPE","edgeLabelSize","Component","defaultProps","nodeLabelColor","edgeLabelColor","$export","__webpack_require__","abs","S","hypot","value1","value2","arg","div","sum","i","aLen","arguments","larg","Infinity","sqrt"],"mappings":"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","file":"component---stories-multi-graph-layout-app-js-f8c98b544396d5179e20.js","sourcesContent":["import {BaseLayout, EDGE_TYPE} from '../../src';\nimport * as d3 from 'd3-force';\n\nconst defaultOptions = {\n  alpha: 3,\n  nBodyStrength: -1200,\n  nBodyDistanceMin: 100,\n  nBodyDistanceMax: 1400,\n};\n\n/**\n * A helper function to compute the control point of a curve\n * @param  {number[]} source  - the coordinates of source point, ex: [x, y, z]\n * @param  {number[]} target  - the coordinates of target point, ex: [x, y, z]\n * @param  {number} direction - the direction of the curve, 1 or -1\n * @param  {number} offset    - offset from the midpoint\n * @return {number[]}         - the coordinates of the control point\n */\nfunction computeControlPoint(source, target, direction, offset) {\n  const midPoint = [(source[0] + target[0]) / 2, (source[1] + target[1]) / 2];\n  const dx = target[0] - source[0];\n  const dy = target[1] - source[1];\n  const normal = [dy, -dx];\n  const length = Math.sqrt(Math.pow(normal[0], 2.0) + Math.pow(normal[1], 2.0));\n  const normalized = [normal[0] / length, normal[1] / length];\n  return [\n    midPoint[0] + normalized[0] * offset * direction,\n    midPoint[1] + normalized[1] * offset * direction,\n  ];\n}\n\nexport default class ForceMultiGraphLayout extends BaseLayout {\n  constructor(options) {\n    super(options);\n    this._name = 'ForceMultiGraphLayout';\n    this._options = {\n      ...defaultOptions,\n      ...options,\n    };\n    // d3 part\n    // custom graph data\n    this._d3Graph = {nodes: [], edges: []};\n    this._nodeMap = {};\n    this._edgeMap = {};\n  }\n\n  initializeGraph(graph) {\n    this.updateGraph(graph);\n  }\n\n  _strength = d3Edge => {\n    if (d3Edge.isVirtual) {\n      return 1 / d3Edge.edgeCount;\n    }\n    const sourceDegree = this._graph.getDegree(d3Edge.source.id);\n    const targetDegree = this._graph.getDegree(d3Edge.target.id);\n    return 1 / Math.min(sourceDegree, targetDegree);\n  };\n\n  _generateSimulator() {\n    if (this._simulator) {\n      this._simulator.on('tick', null).on('end', null);\n      this._simulator = null;\n    }\n    const {\n      alpha,\n      nBodyStrength,\n      nBodyDistanceMin,\n      nBodyDistanceMax,\n    } = this._options;\n\n    const g = this._d3Graph;\n    this._simulator = d3\n      .forceSimulation(g.nodes)\n      .force(\n        'edge',\n        d3\n          .forceLink(g.edges)\n          .id(n => n.id)\n          .strength(this._strength)\n      )\n      .force(\n        'charge',\n        d3\n          .forceManyBody()\n          .strength(nBodyStrength)\n          .distanceMin(nBodyDistanceMin)\n          .distanceMax(nBodyDistanceMax)\n      )\n      .force('center', d3.forceCenter())\n      .alpha(alpha);\n    // register event callbacks\n    this._simulator\n      .on('tick', this._callbacks.onLayoutChange)\n      .on('end', this._callbacks.onLayoutDone);\n  }\n\n  start() {\n    this._generateSimulator();\n    this._simulator.restart();\n  }\n\n  resume() {\n    this._simulator.restart();\n  }\n\n  stop() {\n    this._simulator.stop();\n  }\n\n  updateGraph(graph) {\n    this._graph = graph;\n\n    // nodes\n    const newNodeMap = {};\n    const newD3Nodes = graph.getNodes().map(node => {\n      const oldD3Node = this._nodeMap[node.id];\n      const newD3Node = oldD3Node ? oldD3Node : {id: node.id};\n      newNodeMap[node.id] = newD3Node;\n      return newD3Node;\n    });\n\n    // edges\n    // bucket edges between the same source/target node pairs.\n    const nodePairs = graph.getEdges().reduce((res, edge) => {\n      const nodes = [edge.getSourceNodeId(), edge.getTargetNodeId()];\n      // sort the node ids to count the edges with the same pair\n      // but different direction (a -> b or b -> a)\n      const pairId = nodes.sort().toString();\n      // push this edge into the bucket\n      if (!res[pairId]) {\n        res[pairId] = [edge];\n      } else {\n        res[pairId].push(edge);\n      }\n      return res;\n    }, {});\n\n    // go through each pair of edges,\n    // if only one edge between two nodes, create a straight line\n    // otherwise, create one virtual node and two edges for each edge\n    const newD3Edges = [];\n    const newEdgeMap = {};\n\n    Object.keys(nodePairs).forEach(pairId => {\n      const betweenEdges = nodePairs[pairId];\n      const firstEdge = betweenEdges[0];\n      if (betweenEdges.length === 1) {\n        // do nothing, this is a real edge\n        const newD3Edge = {\n          type: EDGE_TYPE.LINE,\n          id: firstEdge.getId(),\n          source: newNodeMap[firstEdge.getSourceNodeId()],\n          target: newNodeMap[firstEdge.getTargetNodeId()],\n          isVirtual: false,\n        };\n        newEdgeMap[firstEdge.getId()] = newD3Edge;\n        newD3Edges.push(newD3Edge);\n        return;\n      }\n\n      // else reduce to one virtual edge\n      const newD3Edge = {\n        type: EDGE_TYPE.LINE,\n        id: pairId,\n        source: newNodeMap[firstEdge.getSourceNodeId()],\n        target: newNodeMap[firstEdge.getTargetNodeId()],\n        isVirtual: true,\n        edgeCount: betweenEdges.length,\n      };\n      newEdgeMap[pairId] = newD3Edge;\n      newD3Edges.push(newD3Edge);\n\n      betweenEdges.forEach((e, idx) => {\n        newEdgeMap[e.id] = {\n          type: EDGE_TYPE.SPLINE_CURVE,\n          id: e.id,\n          source: newNodeMap[e.getSourceNodeId()],\n          target: newNodeMap[e.getTargetNodeId()],\n          virtualEdgeId: pairId,\n          isVirtual: true,\n          index: idx,\n        };\n      });\n    });\n\n    this._nodeMap = newNodeMap;\n    this._d3Graph.nodes = newD3Nodes;\n    this._edgeMap = newEdgeMap;\n    this._d3Graph.edges = newD3Edges;\n  }\n\n  getNodePosition = node => {\n    const d3Node = this._nodeMap[node.id];\n    if (d3Node) {\n      return [d3Node.x, d3Node.y];\n    }\n    // default value\n    return [0, 0];\n  };\n\n  getEdgePosition = edge => {\n    const d3Edge = this._edgeMap[edge.id];\n    if (d3Edge) {\n      if (!d3Edge.isVirtual) {\n        return {\n          type: EDGE_TYPE.LINE,\n          sourcePosition: [d3Edge.source.x, d3Edge.source.y],\n          targetPosition: [d3Edge.target.x, d3Edge.target.y],\n          controlPoints: [],\n        };\n      }\n      // else, check the referenced virtual edge\n      const virtualEdge = this._edgeMap[d3Edge.virtualEdgeId];\n      const edgeCount = virtualEdge.edgeCount;\n      // get the position of source and target nodes\n      const sourcePosition = [virtualEdge.source.x, virtualEdge.source.y];\n      const targetPosition = [virtualEdge.target.x, virtualEdge.target.y];\n      // calculate a symmetric curve\n      const distance = Math.hypot(\n        sourcePosition[0] - targetPosition[0],\n        sourcePosition[1] - targetPosition[1]\n      );\n      const index = d3Edge.index;\n      // curve direction: inward vs. outward\n      const direction = index % 2 ? 1 : -1;\n      // if the number of the parallel edges is an even number => symmetric shape\n      // otherwise, the 0th node will be a staight line, and rest of them are symmetrical.\n      const symmetricShape = edgeCount % 2 === 0;\n      const offset =\n        Math.max(distance / 10, 5) *\n        (symmetricShape ? Math.floor(index / 2 + 1) : Math.ceil(index / 2));\n      const controlPoint = computeControlPoint(\n        sourcePosition,\n        targetPosition,\n        direction,\n        offset\n      );\n      return {\n        type: EDGE_TYPE.SPLINE_CURVE,\n        sourcePosition,\n        targetPosition,\n        controlPoints: [controlPoint],\n      };\n    }\n    // default value\n    return {\n      type: EDGE_TYPE.LINE,\n      sourcePosition: [0, 0],\n      targetPosition: [0, 0],\n      controlPoints: [],\n    };\n  };\n\n  lockNodePosition = (node, x, y) => {\n    const d3Node = this._nodeMap[node.id];\n    d3Node.x = x;\n    d3Node.y = y;\n    this._callbacks.onLayoutChange();\n    this._callbacks.onLayoutDone();\n  };\n}\n","import React, {Component} from 'react';\nimport Color from 'color';\n\n// data\nimport sampleGraph from './sample-graph.json';\n\n// graph.gl\nimport GraphGL, {EDGE_DECORATOR_TYPE, JSONLoader, NODE_TYPE} from '../../src';\nimport MultiGraphLayout from './multi-graph-layout';\n\nconst DEFAULT_NODE_SIZE = 30;\nconst DEFAULT_NODE_PLACEHOLDER_SIZE = 40;\nconst DEFAULT_NODE_PLACEHOLDER_COLOR = 'rgb(240, 240, 240)';\n\nexport default class MultiGraphExample extends Component {\n  static defaultProps = {\n    showNodePlaceholder: true,\n    showNodeCircle: true,\n    nodeColor: '#cf4569',\n    showNodeLabel: true,\n    nodeLabelColor: '#ffffff',\n    nodeLabelSize: 14,\n    edgeColor: '#cf4569',\n    edgeWidth: 2,\n    showEdgeLabel: true,\n    edgeLabelColor: '#000000',\n    edgeLabelSize: 14,\n  };\n\n  render() {\n    return (\n      <GraphGL\n        graph={JSONLoader({json: sampleGraph})}\n        layout={\n          new MultiGraphLayout({\n            nBodyStrength: -8000,\n          })\n        }\n        nodeStyle={[\n          this.props.showNodePlaceholder && {\n            type: NODE_TYPE.CIRCLE,\n            radius: DEFAULT_NODE_PLACEHOLDER_SIZE,\n            fill: DEFAULT_NODE_PLACEHOLDER_COLOR,\n          },\n          this.props.showNodeCircle && {\n            type: NODE_TYPE.CIRCLE,\n            radius: DEFAULT_NODE_SIZE,\n            fill: this.props.nodeColor,\n          },\n          {\n            type: NODE_TYPE.CIRCLE,\n            radius: node => (node.getPropertyValue('star') ? 6 : 0),\n            fill: [255, 255, 0],\n            offset: [18, -18],\n          },\n          this.props.showNodeLabel && {\n            type: NODE_TYPE.LABEL,\n            text: node => node.getId(),\n            color: Color(this.props.nodeLabelColor).array(),\n            fontSize: this.props.nodeLabelSize,\n          },\n        ]}\n        edgeStyle={{\n          stroke: this.props.edgeColor,\n          strokeWidth: this.props.edgeWidth,\n          decorators: [\n            this.props.showEdgeLabel && {\n              type: EDGE_DECORATOR_TYPE.LABEL,\n              text: edge => edge.getPropertyValue('type'),\n              color: Color(this.props.edgeLabelColor).array(),\n              fontSize: this.props.edgeLabelSize,\n            },\n          ],\n        }}\n      />\n    );\n  }\n}\n","// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])\nvar $export = require('./_export');\nvar abs = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});\n"],"sourceRoot":""}
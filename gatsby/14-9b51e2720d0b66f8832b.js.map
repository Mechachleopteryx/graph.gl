{"version":3,"sources":["webpack:///../node_modules/ngraph.generators/index.js","webpack:///../node_modules/ngraph.generators/node_modules/ngraph.graph/index.js","webpack:///../node_modules/ngraph.events/index.js","webpack:///../node_modules/ngraph.generators/node_modules/ngraph.random/index.js"],"names":["createGraph","__webpack_require__","factory","ladder","complete","n","Error","i","j","g","addLink","completeBipartite","m","balancedBinTree","level","count","Math","pow","addNode","root","left","right","path","circularLadder","grid","node","grid3","z","k","noLinks","wattsStrogatz","p","seed","to","random","neighborsSize","floor","nextDouble","from","newTo","next","needsRewire","hasLink","getLinks","length","link","removeLink","cliqueCircle","cliqueCount","cliqueSize","graph","appendClique","getNodesCount","size","module","exports","options","console","warn","multigraph","uniqueLinkId","undefined","nodes","Object","create","links","multiEdges","nodesCount","suspendEvents","forEachNode","keys","objectKeysIterator","forInIterator","createLink","fromId","toId","data","linkId","makeLinkId","isMultiEdge","hasOwnProperty","getLink","suffix","Link","changes","recordLinkChange","noop","recordNodeChange","enterModification","exitModification","graphPart","fromNode","getNode","toNode","push","addLinkToNode","removeNode","getLinksCount","nodeId","forEachLinkedNode","callback","oriented","forEachOrientedLink","linkedNodeId","forEachNonOrientedLink","forEachLink","beginUpdate","endUpdate","clear","id","hasNode","eventify","realOn","on","enterModificationReal","exitModificationReal","recordLinkChangeReal","recordNodeChangeReal","apply","arguments","changeType","Node","prevLinks","idx","indexOfElementInArray","splice","fromNodeId","toNodeId","fire","element","array","indexOf","len","this","toString","subject","reservedWords","validateSubject","eventsStorage","registeredEvents","eventName","ctx","handlers","off","wantToRemoveAll","deleteAllCallbacksForEvent","callbacks","fireArguments","Array","prototype","call","callbackInfo","createEventsStorage","inputSeed","Generator","Date","randomIterator","customRandom","localRandom","forEach","t","shuffle","maxValue","uniform","gaussian","r","x","y","sqrt","log"],"mappings":"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","file":"14-9b51e2720d0b66f8832b.js","sourcesContent":["var createGraph = require('ngraph.graph');\n\nmodule.exports = factory(createGraph); // Allow other developers have their own createGraph\n\nmodule.exports.factory = factory;\n\nfunction factory(createGraph) {\n  return {\n    ladder: ladder,\n    complete: complete,\n    completeBipartite: completeBipartite,\n    balancedBinTree: balancedBinTree,\n    path: path,\n    circularLadder: circularLadder,\n    grid: grid,\n    grid3: grid3,\n    noLinks: noLinks,\n    wattsStrogatz: wattsStrogatz,\n    cliqueCircle: cliqueCircle\n  };\n\n  function ladder(n) {\n    /**\n    * Ladder graph is a graph in form of ladder\n    * @param {Number} n Represents number of steps in the ladder\n    */\n    if (!n || n < 0) {\n      throw new Error(\"Invalid number of nodes\");\n    }\n\n    var g = createGraph(),\n        i;\n\n    for (i = 0; i < n - 1; ++i) {\n      g.addLink(i, i + 1); // first row\n\n      g.addLink(n + i, n + i + 1); // second row\n\n      g.addLink(i, n + i); // ladder's step\n    }\n\n    g.addLink(n - 1, 2 * n - 1); // last step in the ladder;\n\n    return g;\n  }\n\n  function circularLadder(n) {\n    /**\n    * Circular ladder with n steps.\n    *\n    * @param {Number} n of steps in the ladder.\n    */\n    if (!n || n < 0) {\n      throw new Error(\"Invalid number of nodes\");\n    }\n\n    var g = ladder(n);\n    g.addLink(0, n - 1);\n    g.addLink(n, 2 * n - 1);\n    return g;\n  }\n\n  function complete(n) {\n    /**\n    * Complete graph Kn.\n    *\n    * @param {Number} n represents number of nodes in the complete graph.\n    */\n    if (!n || n < 1) {\n      throw new Error(\"At least two nodes are expected for complete graph\");\n    }\n\n    var g = createGraph(),\n        i,\n        j;\n\n    for (i = 0; i < n; ++i) {\n      for (j = i + 1; j < n; ++j) {\n        if (i !== j) {\n          g.addLink(i, j);\n        }\n      }\n    }\n\n    return g;\n  }\n\n  function completeBipartite(n, m) {\n    /**\n    * Complete bipartite graph K n,m. Each node in the\n    * first partition is connected to all nodes in the second partition.\n    *\n    * @param {Number} n represents number of nodes in the first graph partition\n    * @param {Number} m represents number of nodes in the second graph partition\n    */\n    if (!n || !m || n < 0 || m < 0) {\n      throw new Error(\"Graph dimensions are invalid. Number of nodes in each partition should be greater than 0\");\n    }\n\n    var g = createGraph(),\n        i,\n        j;\n\n    for (i = 0; i < n; ++i) {\n      for (j = n; j < n + m; ++j) {\n        g.addLink(i, j);\n      }\n    }\n\n    return g;\n  }\n\n  function path(n) {\n    /**\n    * Path graph with n steps.\n    *\n    * @param {Number} n number of nodes in the path\n    */\n    if (!n || n < 0) {\n      throw new Error(\"Invalid number of nodes\");\n    }\n\n    var g = createGraph(),\n        i;\n    g.addNode(0);\n\n    for (i = 1; i < n; ++i) {\n      g.addLink(i - 1, i);\n    }\n\n    return g;\n  }\n\n  function grid(n, m) {\n    /**\n    * Grid graph with n rows and m columns.\n    *\n    * @param {Number} n of rows in the graph.\n    * @param {Number} m of columns in the graph.\n    */\n    if (n < 1 || m < 1) {\n      throw new Error(\"Invalid number of nodes in grid graph\");\n    }\n\n    var g = createGraph(),\n        i,\n        j;\n\n    if (n === 1 && m === 1) {\n      g.addNode(0);\n      return g;\n    }\n\n    for (i = 0; i < n; ++i) {\n      for (j = 0; j < m; ++j) {\n        var node = i + j * n;\n\n        if (i > 0) {\n          g.addLink(node, i - 1 + j * n);\n        }\n\n        if (j > 0) {\n          g.addLink(node, i + (j - 1) * n);\n        }\n      }\n    }\n\n    return g;\n  }\n\n  function grid3(n, m, z) {\n    /**\n    * 3D grid with n rows and m columns and z levels.\n    *\n    * @param {Number} n of rows in the graph.\n    * @param {Number} m of columns in the graph.\n    * @param {Number} z of levels in the graph.\n    */\n    if (n < 1 || m < 1 || z < 1) {\n      throw new Error(\"Invalid number of nodes in grid3 graph\");\n    }\n\n    var g = createGraph(),\n        i,\n        j,\n        k;\n\n    if (n === 1 && m === 1 && z === 1) {\n      g.addNode(0);\n      return g;\n    }\n\n    for (k = 0; k < z; ++k) {\n      for (i = 0; i < n; ++i) {\n        for (j = 0; j < m; ++j) {\n          var level = k * n * m;\n          var node = i + j * n + level;\n\n          if (i > 0) {\n            g.addLink(node, i - 1 + j * n + level);\n          }\n\n          if (j > 0) {\n            g.addLink(node, i + (j - 1) * n + level);\n          }\n\n          if (k > 0) {\n            g.addLink(node, i + j * n + (k - 1) * n * m);\n          }\n        }\n      }\n    }\n\n    return g;\n  }\n\n  function balancedBinTree(n) {\n    /**\n    * Balanced binary tree with n levels.\n    *\n    * @param {Number} n of levels in the binary tree\n    */\n    if (n < 0) {\n      throw new Error(\"Invalid number of nodes in balanced tree\");\n    }\n\n    var g = createGraph(),\n        count = Math.pow(2, n),\n        level;\n\n    if (n === 0) {\n      g.addNode(1);\n    }\n\n    for (level = 1; level < count; ++level) {\n      var root = level,\n          left = root * 2,\n          right = root * 2 + 1;\n      g.addLink(root, left);\n      g.addLink(root, right);\n    }\n\n    return g;\n  }\n\n  function noLinks(n) {\n    /**\n    * Graph with no links\n    *\n    * @param {Number} n of nodes in the graph\n    */\n    if (n < 0) {\n      throw new Error(\"Number of nodes should be >= 0\");\n    }\n\n    var g = createGraph(),\n        i;\n\n    for (i = 0; i < n; ++i) {\n      g.addNode(i);\n    }\n\n    return g;\n  }\n\n  function cliqueCircle(cliqueCount, cliqueSize) {\n    /**\n    * A circular graph with cliques instead of individual nodes\n    *\n    * @param {Number} cliqueCount number of cliques inside circle\n    * @param {Number} cliqueSize number of nodes inside each clique\n    */\n    if (cliqueCount < 1) throw new Error('Invalid number of cliqueCount in cliqueCircle');\n    if (cliqueSize < 1) throw new Error('Invalid number of cliqueSize in cliqueCircle');\n    var graph = createGraph();\n\n    for (var i = 0; i < cliqueCount; ++i) {\n      appendClique(cliqueSize, i * cliqueSize);\n\n      if (i > 0) {\n        graph.addLink(i * cliqueSize, i * cliqueSize - 1);\n      }\n    }\n\n    graph.addLink(0, graph.getNodesCount() - 1);\n    return graph;\n\n    function appendClique(size, from) {\n      for (var i = 0; i < size; ++i) {\n        graph.addNode(i + from);\n      }\n\n      for (var i = 0; i < size; ++i) {\n        for (var j = i + 1; j < size; ++j) {\n          graph.addLink(i + from, j + from);\n        }\n      }\n    }\n  }\n\n  function wattsStrogatz(n, k, p, seed) {\n    /**\n    * Watts-Strogatz small-world graph.\n    *\n    * @param {Number} n The number of nodes\n    * @param {Number} k Each node is connected to k nearest neighbors in ring topology\n    * @param {Number} p The probability of rewiring each edge\n     * @see https://github.com/networkx/networkx/blob/master/networkx/generators/random_graphs.py\n    */\n    if (k >= n) throw new Error('Choose smaller `k`. It cannot be larger than number of nodes `n`');\n\n    var random = require('ngraph.random').random(seed || 42);\n\n    var g = createGraph(),\n        i,\n        to;\n\n    for (i = 0; i < n; ++i) {\n      g.addNode(i);\n    } // connect each node to k/2 neighbors\n\n\n    var neighborsSize = Math.floor(k / 2 + 1);\n\n    for (var j = 1; j < neighborsSize; ++j) {\n      for (i = 0; i < n; ++i) {\n        to = (j + i) % n;\n        g.addLink(i, to);\n      }\n    } // rewire edges from each node\n    // loop over all nodes in order (label) and neighbors in order (distance)\n    // no self loops or multiple edges allowed\n\n\n    for (j = 1; j < neighborsSize; ++j) {\n      for (i = 0; i < n; ++i) {\n        if (random.nextDouble() < p) {\n          var from = i;\n          to = (j + i) % n;\n          var newTo = random.next(n);\n          var needsRewire = newTo === from || g.hasLink(from, newTo);\n\n          if (needsRewire && g.getLinks(from).length === n - 1) {\n            // we cannot rewire this node, it has too many links.\n            continue;\n          } // Enforce no self-loops or multiple edges\n\n\n          while (needsRewire) {\n            newTo = random.next(n);\n            needsRewire = newTo === from || g.hasLink(from, newTo);\n          }\n\n          var link = g.hasLink(from, to);\n          g.removeLink(link);\n          g.addLink(from, newTo);\n        }\n      }\n    }\n\n    return g;\n  }\n}","require(\"core-js/modules/es6.regexp.to-string\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\nrequire(\"core-js/modules/es6.array.iterator\");\n\nrequire(\"core-js/modules/es6.object.to-string\");\n\nrequire(\"core-js/modules/es6.object.keys\");\n\n/**\n * @fileOverview Contains definition of the core graph object.\n */\n// TODO: need to change storage layer:\n// 1. Be able to get all nodes O(1)\n// 2. Be able to get number of links O(1)\n\n/**\n * @example\n *  var graph = require('ngraph.graph')();\n *  graph.addNode(1);     // graph has one node.\n *  graph.addLink(2, 3);  // now graph contains three nodes and one link.\n *\n */\nmodule.exports = createGraph;\n\nvar eventify = require('ngraph.events');\n/**\n * Creates a new graph\n */\n\n\nfunction createGraph(options) {\n  // Graph structure is maintained as dictionary of nodes\n  // and array of links. Each node has 'links' property which\n  // hold all links related to that node. And general links\n  // array is used to speed up all links enumeration. This is inefficient\n  // in terms of memory, but simplifies coding.\n  options = options || {};\n\n  if ('uniqueLinkId' in options) {\n    console.warn('ngraph.graph: Starting from version 0.14 `uniqueLinkId` is deprecated.\\n' + 'Use `multigraph` option instead\\n', '\\n', 'Note: there is also change in default behavior: From now on each graph\\n' + 'is considered to be not a multigraph by default (each edge is unique).');\n    options.multigraph = options.uniqueLinkId;\n  } // Dear reader, the non-multigraphs do not guarantee that there is only\n  // one link for a given pair of node. When this option is set to false\n  // we can save some memory and CPU (18% faster for non-multigraph);\n\n\n  if (options.multigraph === undefined) options.multigraph = false;\n  var nodes = typeof Object.create === 'function' ? Object.create(null) : {},\n      links = [],\n      // Hash of multi-edges. Used to track ids of edges between same nodes\n  multiEdges = {},\n      nodesCount = 0,\n      suspendEvents = 0,\n      forEachNode = createNodeIterator(),\n      createLink = options.multigraph ? createUniqueLink : createSingleLink,\n      // Our graph API provides means to listen to graph changes. Users can subscribe\n  // to be notified about changes in the graph by using `on` method. However\n  // in some cases they don't use it. To avoid unnecessary memory consumption\n  // we will not record graph changes until we have at least one subscriber.\n  // Code below supports this optimization.\n  //\n  // Accumulates all changes made during graph updates.\n  // Each change element contains:\n  //  changeType - one of the strings: 'add', 'remove' or 'update';\n  //  node - if change is related to node this property is set to changed graph's node;\n  //  link - if change is related to link this property is set to changed graph's link;\n  changes = [],\n      recordLinkChange = noop,\n      recordNodeChange = noop,\n      enterModification = noop,\n      exitModification = noop; // this is our public API:\n\n  var graphPart = {\n    /**\n     * Adds node to the graph. If node with given id already exists in the graph\n     * its data is extended with whatever comes in 'data' argument.\n     *\n     * @param nodeId the node's identifier. A string or number is preferred.\n     * @param [data] additional data for the node being added. If node already\n     *   exists its data object is augmented with the new one.\n     *\n     * @return {node} The newly added node or node with given id if it already exists.\n     */\n    addNode: addNode,\n\n    /**\n     * Adds a link to the graph. The function always create a new\n     * link between two nodes. If one of the nodes does not exists\n     * a new node is created.\n     *\n     * @param fromId link start node id;\n     * @param toId link end node id;\n     * @param [data] additional data to be set on the new link;\n     *\n     * @return {link} The newly created link\n     */\n    addLink: addLink,\n\n    /**\n     * Removes link from the graph. If link does not exist does nothing.\n     *\n     * @param link - object returned by addLink() or getLinks() methods.\n     *\n     * @returns true if link was removed; false otherwise.\n     */\n    removeLink: removeLink,\n\n    /**\n     * Removes node with given id from the graph. If node does not exist in the graph\n     * does nothing.\n     *\n     * @param nodeId node's identifier passed to addNode() function.\n     *\n     * @returns true if node was removed; false otherwise.\n     */\n    removeNode: removeNode,\n\n    /**\n     * Gets node with given identifier. If node does not exist undefined value is returned.\n     *\n     * @param nodeId requested node identifier;\n     *\n     * @return {node} in with requested identifier or undefined if no such node exists.\n     */\n    getNode: getNode,\n\n    /**\n     * Gets number of nodes in this graph.\n     *\n     * @return number of nodes in the graph.\n     */\n    getNodesCount: function getNodesCount() {\n      return nodesCount;\n    },\n\n    /**\n     * Gets total number of links in the graph.\n     */\n    getLinksCount: function getLinksCount() {\n      return links.length;\n    },\n\n    /**\n     * Gets all links (inbound and outbound) from the node with given id.\n     * If node with given id is not found null is returned.\n     *\n     * @param nodeId requested node identifier.\n     *\n     * @return Array of links from and to requested node if such node exists;\n     *   otherwise null is returned.\n     */\n    getLinks: getLinks,\n\n    /**\n     * Invokes callback on each node of the graph.\n     *\n     * @param {Function(node)} callback Function to be invoked. The function\n     *   is passed one argument: visited node.\n     */\n    forEachNode: forEachNode,\n\n    /**\n     * Invokes callback on every linked (adjacent) node to the given one.\n     *\n     * @param nodeId Identifier of the requested node.\n     * @param {Function(node, link)} callback Function to be called on all linked nodes.\n     *   The function is passed two parameters: adjacent node and link object itself.\n     * @param oriented if true graph treated as oriented.\n     */\n    forEachLinkedNode: forEachLinkedNode,\n\n    /**\n     * Enumerates all links in the graph\n     *\n     * @param {Function(link)} callback Function to be called on all links in the graph.\n     *   The function is passed one parameter: graph's link object.\n     *\n     * Link object contains at least the following fields:\n     *  fromId - node id where link starts;\n     *  toId - node id where link ends,\n     *  data - additional data passed to graph.addLink() method.\n     */\n    forEachLink: forEachLink,\n\n    /**\n     * Suspend all notifications about graph changes until\n     * endUpdate is called.\n     */\n    beginUpdate: enterModification,\n\n    /**\n     * Resumes all notifications about graph changes and fires\n     * graph 'changed' event in case there are any pending changes.\n     */\n    endUpdate: exitModification,\n\n    /**\n     * Removes all nodes and links from the graph.\n     */\n    clear: clear,\n\n    /**\n     * Detects whether there is a link between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     * NOTE: this function is synonim for getLink()\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    hasLink: getLink,\n\n    /**\n     * Detects whether there is a node with given id\n     * \n     * Operation complexity is O(1)\n     * NOTE: this function is synonim for getNode()\n     *\n     * @returns node if there is one; Falsy value otherwise.\n     */\n    hasNode: getNode,\n\n    /**\n     * Gets an edge between two nodes.\n     * Operation complexity is O(n) where n - number of links of a node.\n     *\n     * @param {string} fromId link start identifier\n     * @param {string} toId link end identifier\n     *\n     * @returns link if there is one. null otherwise.\n     */\n    getLink: getLink\n  }; // this will add `on()` and `fire()` methods.\n\n  eventify(graphPart);\n  monitorSubscribers();\n  return graphPart;\n\n  function monitorSubscribers() {\n    var realOn = graphPart.on; // replace real `on` with our temporary on, which will trigger change\n    // modification monitoring:\n\n    graphPart.on = on;\n\n    function on() {\n      // now it's time to start tracking stuff:\n      graphPart.beginUpdate = enterModification = enterModificationReal;\n      graphPart.endUpdate = exitModification = exitModificationReal;\n      recordLinkChange = recordLinkChangeReal;\n      recordNodeChange = recordNodeChangeReal; // this will replace current `on` method with real pub/sub from `eventify`.\n\n      graphPart.on = realOn; // delegate to real `on` handler:\n\n      return realOn.apply(graphPart, arguments);\n    }\n  }\n\n  function recordLinkChangeReal(link, changeType) {\n    changes.push({\n      link: link,\n      changeType: changeType\n    });\n  }\n\n  function recordNodeChangeReal(node, changeType) {\n    changes.push({\n      node: node,\n      changeType: changeType\n    });\n  }\n\n  function addNode(nodeId, data) {\n    if (nodeId === undefined) {\n      throw new Error('Invalid node identifier');\n    }\n\n    enterModification();\n    var node = getNode(nodeId);\n\n    if (!node) {\n      node = new Node(nodeId, data);\n      nodesCount++;\n      recordNodeChange(node, 'add');\n    } else {\n      node.data = data;\n      recordNodeChange(node, 'update');\n    }\n\n    nodes[nodeId] = node;\n    exitModification();\n    return node;\n  }\n\n  function getNode(nodeId) {\n    return nodes[nodeId];\n  }\n\n  function removeNode(nodeId) {\n    var node = getNode(nodeId);\n\n    if (!node) {\n      return false;\n    }\n\n    enterModification();\n    var prevLinks = node.links;\n\n    if (prevLinks) {\n      node.links = null;\n\n      for (var i = 0; i < prevLinks.length; ++i) {\n        removeLink(prevLinks[i]);\n      }\n    }\n\n    delete nodes[nodeId];\n    nodesCount--;\n    recordNodeChange(node, 'remove');\n    exitModification();\n    return true;\n  }\n\n  function addLink(fromId, toId, data) {\n    enterModification();\n    var fromNode = getNode(fromId) || addNode(fromId);\n    var toNode = getNode(toId) || addNode(toId);\n    var link = createLink(fromId, toId, data);\n    links.push(link); // TODO: this is not cool. On large graphs potentially would consume more memory.\n\n    addLinkToNode(fromNode, link);\n\n    if (fromId !== toId) {\n      // make sure we are not duplicating links for self-loops\n      addLinkToNode(toNode, link);\n    }\n\n    recordLinkChange(link, 'add');\n    exitModification();\n    return link;\n  }\n\n  function createSingleLink(fromId, toId, data) {\n    var linkId = makeLinkId(fromId, toId);\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function createUniqueLink(fromId, toId, data) {\n    // TODO: Get rid of this method.\n    var linkId = makeLinkId(fromId, toId);\n    var isMultiEdge = multiEdges.hasOwnProperty(linkId);\n\n    if (isMultiEdge || getLink(fromId, toId)) {\n      if (!isMultiEdge) {\n        multiEdges[linkId] = 0;\n      }\n\n      var suffix = '@' + ++multiEdges[linkId];\n      linkId = makeLinkId(fromId + suffix, toId + suffix);\n    }\n\n    return new Link(fromId, toId, data, linkId);\n  }\n\n  function getLinks(nodeId) {\n    var node = getNode(nodeId);\n    return node ? node.links : null;\n  }\n\n  function removeLink(link) {\n    if (!link) {\n      return false;\n    }\n\n    var idx = indexOfElementInArray(link, links);\n\n    if (idx < 0) {\n      return false;\n    }\n\n    enterModification();\n    links.splice(idx, 1);\n    var fromNode = getNode(link.fromId);\n    var toNode = getNode(link.toId);\n\n    if (fromNode) {\n      idx = indexOfElementInArray(link, fromNode.links);\n\n      if (idx >= 0) {\n        fromNode.links.splice(idx, 1);\n      }\n    }\n\n    if (toNode) {\n      idx = indexOfElementInArray(link, toNode.links);\n\n      if (idx >= 0) {\n        toNode.links.splice(idx, 1);\n      }\n    }\n\n    recordLinkChange(link, 'remove');\n    exitModification();\n    return true;\n  }\n\n  function getLink(fromNodeId, toNodeId) {\n    // TODO: Use sorted links to speed this up\n    var node = getNode(fromNodeId),\n        i;\n\n    if (!node || !node.links) {\n      return null;\n    }\n\n    for (i = 0; i < node.links.length; ++i) {\n      var link = node.links[i];\n\n      if (link.fromId === fromNodeId && link.toId === toNodeId) {\n        return link;\n      }\n    }\n\n    return null; // no link.\n  }\n\n  function clear() {\n    enterModification();\n    forEachNode(function (node) {\n      removeNode(node.id);\n    });\n    exitModification();\n  }\n\n  function forEachLink(callback) {\n    var i, length;\n\n    if (typeof callback === 'function') {\n      for (i = 0, length = links.length; i < length; ++i) {\n        callback(links[i]);\n      }\n    }\n  }\n\n  function forEachLinkedNode(nodeId, callback, oriented) {\n    var node = getNode(nodeId);\n\n    if (node && node.links && typeof callback === 'function') {\n      if (oriented) {\n        return forEachOrientedLink(node.links, nodeId, callback);\n      } else {\n        return forEachNonOrientedLink(node.links, nodeId, callback);\n      }\n    }\n  }\n\n  function forEachNonOrientedLink(links, nodeId, callback) {\n    var quitFast;\n\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n      var linkedNodeId = link.fromId === nodeId ? link.toId : link.fromId;\n      quitFast = callback(nodes[linkedNodeId], link);\n\n      if (quitFast) {\n        return true; // Client does not need more iterations. Break now.\n      }\n    }\n  }\n\n  function forEachOrientedLink(links, nodeId, callback) {\n    var quitFast;\n\n    for (var i = 0; i < links.length; ++i) {\n      var link = links[i];\n\n      if (link.fromId === nodeId) {\n        quitFast = callback(nodes[link.toId], link);\n\n        if (quitFast) {\n          return true; // Client does not need more iterations. Break now.\n        }\n      }\n    }\n  } // we will not fire anything until users of this library explicitly call `on()`\n  // method.\n\n\n  function noop() {} // Enter, Exit modification allows bulk graph updates without firing events.\n\n\n  function enterModificationReal() {\n    suspendEvents += 1;\n  }\n\n  function exitModificationReal() {\n    suspendEvents -= 1;\n\n    if (suspendEvents === 0 && changes.length > 0) {\n      graphPart.fire('changed', changes);\n      changes.length = 0;\n    }\n  }\n\n  function createNodeIterator() {\n    // Object.keys iterator is 1.3x faster than `for in` loop.\n    // See `https://github.com/anvaka/ngraph.graph/tree/bench-for-in-vs-obj-keys`\n    // branch for perf test\n    return Object.keys ? objectKeysIterator : forInIterator;\n  }\n\n  function objectKeysIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n\n    var keys = Object.keys(nodes);\n\n    for (var i = 0; i < keys.length; ++i) {\n      if (callback(nodes[keys[i]])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n\n  function forInIterator(callback) {\n    if (typeof callback !== 'function') {\n      return;\n    }\n\n    var node;\n\n    for (node in nodes) {\n      if (callback(nodes[node])) {\n        return true; // client doesn't want to proceed. Return.\n      }\n    }\n  }\n} // need this for old browsers. Should this be a separate module?\n\n\nfunction indexOfElementInArray(element, array) {\n  if (!array) return -1;\n\n  if (array.indexOf) {\n    return array.indexOf(element);\n  }\n\n  var len = array.length,\n      i;\n\n  for (i = 0; i < len; i += 1) {\n    if (array[i] === element) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n/**\n * Internal structure to represent node;\n */\n\n\nfunction Node(id, data) {\n  this.id = id;\n  this.links = null;\n  this.data = data;\n}\n\nfunction addLinkToNode(node, link) {\n  if (node.links) {\n    node.links.push(link);\n  } else {\n    node.links = [link];\n  }\n}\n/**\n * Internal structure to represent links;\n */\n\n\nfunction Link(fromId, toId, data, id) {\n  this.fromId = fromId;\n  this.toId = toId;\n  this.data = data;\n  this.id = id;\n}\n\nfunction hashCode(str) {\n  var hash = 0,\n      i,\n      chr,\n      len;\n  if (str.length == 0) return hash;\n\n  for (i = 0, len = str.length; i < len; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return hash;\n}\n\nfunction makeLinkId(fromId, toId) {\n  return fromId.toString() + '👉 ' + toId.toString();\n}","module.exports = function (subject) {\n  validateSubject(subject);\n  var eventsStorage = createEventsStorage(subject);\n  subject.on = eventsStorage.on;\n  subject.off = eventsStorage.off;\n  subject.fire = eventsStorage.fire;\n  return subject;\n};\n\nfunction createEventsStorage(subject) {\n  // Store all event listeners to this hash. Key is event name, value is array\n  // of callback records.\n  //\n  // A callback record consists of callback function and its optional context:\n  // { 'eventName' => [{callback: function, ctx: object}] }\n  var registeredEvents = Object.create(null);\n  return {\n    on: function on(eventName, callback, ctx) {\n      if (typeof callback !== 'function') {\n        throw new Error('callback is expected to be a function');\n      }\n\n      var handlers = registeredEvents[eventName];\n\n      if (!handlers) {\n        handlers = registeredEvents[eventName] = [];\n      }\n\n      handlers.push({\n        callback: callback,\n        ctx: ctx\n      });\n      return subject;\n    },\n    off: function off(eventName, callback) {\n      var wantToRemoveAll = typeof eventName === 'undefined';\n\n      if (wantToRemoveAll) {\n        // Killing old events storage should be enough in this case:\n        registeredEvents = Object.create(null);\n        return subject;\n      }\n\n      if (registeredEvents[eventName]) {\n        var deleteAllCallbacksForEvent = typeof callback !== 'function';\n\n        if (deleteAllCallbacksForEvent) {\n          delete registeredEvents[eventName];\n        } else {\n          var callbacks = registeredEvents[eventName];\n\n          for (var i = 0; i < callbacks.length; ++i) {\n            if (callbacks[i].callback === callback) {\n              callbacks.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      return subject;\n    },\n    fire: function fire(eventName) {\n      var callbacks = registeredEvents[eventName];\n\n      if (!callbacks) {\n        return subject;\n      }\n\n      var fireArguments;\n\n      if (arguments.length > 1) {\n        fireArguments = Array.prototype.splice.call(arguments, 1);\n      }\n\n      for (var i = 0; i < callbacks.length; ++i) {\n        var callbackInfo = callbacks[i];\n        callbackInfo.callback.apply(callbackInfo.ctx, fireArguments);\n      }\n\n      return subject;\n    }\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('Eventify cannot use falsy object as events subject');\n  }\n\n  var reservedWords = ['on', 'fire', 'off'];\n\n  for (var i = 0; i < reservedWords.length; ++i) {\n    if (subject.hasOwnProperty(reservedWords[i])) {\n      throw new Error(\"Subject cannot be eventified, since it already has property '\" + reservedWords[i] + \"'\");\n    }\n  }\n}","module.exports = random; // TODO: Deprecate?\n\nmodule.exports.random = random, module.exports.randomIterator = randomIterator;\n/**\n * Creates seeded PRNG with two methods:\n *   next() and nextDouble()\n */\n\nfunction random(inputSeed) {\n  var seed = typeof inputSeed === 'number' ? inputSeed : +new Date();\n  return new Generator(seed);\n}\n\nfunction Generator(seed) {\n  this.seed = seed;\n}\n/**\n  * Generates random integer number in the range from 0 (inclusive) to maxValue (exclusive)\n  *\n  * @param maxValue Number REQUIRED. Omitting this number will result in NaN values from PRNG.\n  */\n\n\nGenerator.prototype.next = next;\n/**\n  * Generates random double number in the range from 0 (inclusive) to 1 (exclusive)\n  * This function is the same as Math.random() (except that it could be seeded)\n  */\n\nGenerator.prototype.nextDouble = nextDouble;\n/**\n * Returns a random real number uniformly in [0, 1)\n */\n\nGenerator.prototype.uniform = nextDouble;\nGenerator.prototype.gaussian = gaussian;\n\nfunction gaussian() {\n  // use the polar form of the Box-Muller transform\n  // based on https://introcs.cs.princeton.edu/java/23recursion/StdRandom.java\n  var r, x, y;\n\n  do {\n    x = this.nextDouble() * 2 - 1;\n    y = this.nextDouble() * 2 - 1;\n    r = x * x + y * y;\n  } while (r >= 1 || r === 0);\n\n  return x * Math.sqrt(-2 * Math.log(r) / r);\n}\n\nfunction nextDouble() {\n  var seed = this.seed; // Robert Jenkins' 32 bit integer hash function.\n\n  seed = seed + 0x7ed55d16 + (seed << 12) & 0xffffffff;\n  seed = (seed ^ 0xc761c23c ^ seed >>> 19) & 0xffffffff;\n  seed = seed + 0x165667b1 + (seed << 5) & 0xffffffff;\n  seed = (seed + 0xd3a2646c ^ seed << 9) & 0xffffffff;\n  seed = seed + 0xfd7046c5 + (seed << 3) & 0xffffffff;\n  seed = (seed ^ 0xb55a4f09 ^ seed >>> 16) & 0xffffffff;\n  this.seed = seed;\n  return (seed & 0xfffffff) / 0x10000000;\n}\n\nfunction next(maxValue) {\n  return Math.floor(this.nextDouble() * maxValue);\n}\n/*\n * Creates iterator over array, which returns items of array in random order\n * Time complexity is guaranteed to be O(n);\n */\n\n\nfunction randomIterator(array, customRandom) {\n  var localRandom = customRandom || random();\n\n  if (typeof localRandom.next !== 'function') {\n    throw new Error('customRandom does not match expected API: next() function is missing');\n  }\n\n  return {\n    forEach: forEach,\n\n    /**\n     * Shuffles array randomly, in place.\n     */\n    shuffle: shuffle\n  };\n\n  function shuffle() {\n    var i, j, t;\n\n    for (i = array.length - 1; i > 0; --i) {\n      j = localRandom.next(i + 1); // i inclusive\n\n      t = array[j];\n      array[j] = array[i];\n      array[i] = t;\n    }\n\n    return array;\n  }\n\n  function forEach(callback) {\n    var i, j, t;\n\n    for (i = array.length - 1; i > 0; --i) {\n      j = localRandom.next(i + 1); // i inclusive\n\n      t = array[j];\n      array[j] = array[i];\n      array[i] = t;\n      callback(t);\n    }\n\n    if (array.length) {\n      callback(array[0]);\n    }\n  }\n}"],"sourceRoot":""}